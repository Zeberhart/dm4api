import asyncio
from sanic import Sanic
from sanic.response import file
from sanic.response import json, text
import json as js
import time
import traceback
import sys
import argparse
import os
import nltk
import threading
nltk.download('stopwords')
dm4apidir = os.path.join("..", "..", "dm4api", "src")
sys.path.append(dm4apidir)
from dm4api import create_env, create_agent

schemedir = os.path.join("..", "..", "dm4api", "data", "schema", "new_scheme")
apidir = os.path.join("..", "..", "dm4api", "data", "apis")
learneddir_allegro = os.path.join("..", "..", "dm4api", "data",  "weights", "MultiInput_DefaultEnv_allegro", "1200000")
learneddir_libssh = os.path.join("..", "..", "dm4api", "data",  "weights", "MultiInput_DefaultEnv_libssh", "5200000")



application = Sanic(name="DefaultEnv")

shared_envs = {
    
}

rl_agents = {
    
}

class UserSession:
    env = create_env("DefaultEnv", schemedir=schemedir, apidir=os.path.join(apidir, "libssh"))
    agent = create_agent("DefaultHCAgent", env=env)

    query = ""
    requested_feature = ""

    def __init__(self):
        self.restart()
        
    def restart(self):
        self.requested_feature = ""
        self.agent.reset_states()
        self.env.interactive_reset()

    def reconfigure(self, agent, library):
        self.env = create_env("DefaultEnv", schemedir=schemedir, apidir=os.path.join(apidir, library))
        if agent == "rl":
            self.agent = rl_agents[library]
        elif agent=="hc":
            self.agent = create_agent("DefaultHCAgent", env=self.env)
        elif agent=="search":
            self.agent = create_agent("DefaultBaselineAgent", env=self.env)
        self.restart()

    def processMessage(self, message):
        '''
            Processes the user's request and generates a system response

            Called from the main loop whenever the user sends a message.
        '''
        self._updateSearch(message)
        user_action = self._translateUserAction(message)
        self.env.processUserAction(user_action)
        observation = self.env.generateObservation()

        self.env.current_turn += 1
        action = self.agent.forward(observation)
        system_action = self.env.parseAction(action)
        self.env.processSystemAction(system_action)
        response = self._translateSystemAction(system_action)
        return response

    def _updateSearch(self, message):
        '''
            Updates the user's query depending on the type of the user's message
        '''
        mtype = message["type"]
        user_action = {"action":mtype}
        if "feature" in message:
            self.requested_feature = message["feature"]

    def _translateUserAction(self, message):
        '''
            Translates the message sent over the websocket to the format required 
        '''
        mtype = message["type"]
        user_action = {"action":mtype}

        if mtype == "provide-query":
            user_action["query"] = message["query"]

        elif mtype == "provide-kw":
            user_action["keyword"] = message["keyword"]

        elif mtype == "reject-kws":
            user_action["keywords"] = message["keywords"]

        elif mtype == "reject-functions":
            user_action["functions"] = message["functions"]

        elif mtype == "change-page":
            pass

        elif mtype == "eli-info":
            user_action["function"] = message["function"]

        elif mtype == "eli-info-all":
            user_action["function"] = message["function"]

        elif mtype == "eli-sugg":
            pass

        elif mtype == "eli-sugg-all":
            pass

        elif mtype == "dont-know":
            pass

        else:
            raise Exception("Unknown message type encountered") 

        return user_action

    def _translateSystemAction(self, system_action):
        '''
            Translates the action generated by the system to one to be sent over the WS.

            Note that we add a "-s" to the end of the action type in the response. This is so the 
            frontend can distinguish system actions from user actions with the same name
            (in future iterations, DON'T USE THE SAME NAME FOR SYS AND USER ACTIONS)
        '''
        mtype = system_action["action"]
        response = {"type": mtype}

        if mtype == "info":
            if "function" in system_action and system_action["function"]:
                response["function"] = system_action["function"]
                response["feature"] = self.requested_feature
            else:
                print("System tried to inform w/ no function")
                response["type"] = "eli-query"

        elif mtype == "info-all":
            if "function" in system_action and system_action["function"]:
                response["function"] = system_action["function"]
            else:
                print("System tried to inform w/ no function")
                response["type"] = "eli-query"

        elif mtype == "sugg":
            response["function"] = system_action["function"]

        elif mtype == "sugg-info-all":
            response["function"] = system_action["function"]

        elif mtype == "sugg-all":
            response["functions"] = system_action["list"]

        elif mtype == "change-page":
            response["functions"] = system_action["list"]

        elif mtype == "eli-kw":
            response["keywords"] = system_action["keywords"]

        elif mtype == "eli-query":
            pass

        elif mtype == "START":
            pass

        else:
            raise Exception("Unknown system action encountered") 

        response["type"] += "-s"
        return response

    def _funcToIndex(self, function):
        index = self.env.dataset.functions.index(function)
        return index

    def _indexesToFunc(self, indexes):
        function_list = [self.env.dataset.functions[i] for i in indexes]
        return function_list

async def helpSequence(ws, data={}):
    await asyncio.sleep(.2)
    await ws.send(js.dumps({"type":"typing"}))
    await asyncio.sleep(1)
    await ws.send(js.dumps({"type":"START", "text": "Hello! To get started, use the bar below to search \
        for functions in the API."})) 

    await asyncio.sleep(.2)
    await ws.send(js.dumps({"type":"typing"}))
    await asyncio.sleep(1)
    await ws.send(js.dumps({"type":"START", "text": "Use a \"+\" to add a keyword. You can only send one keyword at a time. Example: +connect"})) 

    await asyncio.sleep(.2)
    await ws.send(js.dumps({"type":"typing"}))
    await asyncio.sleep(1)
    await ws.send(js.dumps({"type":"START", "text": "Use an \"@\" to ask about a particular function. Example: @ssh_new"}))

    await asyncio.sleep(.2)
    await ws.send(js.dumps({"type":"typing"}))
    await asyncio.sleep(1)
    await ws.send(js.dumps({"type":"START", "text": "You can also click on quick responses below system messages, or keywords/function names inside of certain system messages."})) 

async def startSequence(ws):
    await asyncio.sleep(.5)
    await ws.send(js.dumps({"type":"typing"}))
    await asyncio.sleep(1)
    await ws.send(js.dumps({"type":"START", "text":"Hello! Please enter a query, +keyword, or @function name to begin."})) 

async def restartSequence(ws):
    await ws.send(js.dumps({"type":"RESTART"})) 
    await asyncio.sleep(.5)
    await ws.send(js.dumps({"type":"typing"}))
    await asyncio.sleep(1)
    await ws.send(js.dumps({"type":"START", "text":"How can I help? Please enter a query, +keyword, or @function name to begin."})) 

async def setRLSequence(ws, using_rl):
    agent_type = "RL" if using_rl else "Basic"
    await ws.send(js.dumps({"type":"RESTART"})) 
    await asyncio.sleep(.5)
    await ws.send(js.dumps({"type":"typing"}))
    await asyncio.sleep(1)
    await ws.send(js.dumps({"type":"START", "text":"You are now using the %s search agent."%agent_type}))
    await asyncio.sleep(.5)
    await ws.send(js.dumps({"type":"typing"}))
    await asyncio.sleep(1)
    await ws.send(js.dumps({"type":"START", "text":"How can I help? Please enter a query, +keyword, or @function name to begin."}))  

@application.route('/functions/<library>')
async def functions(request, library):
    data = shared_envs[library].functions
    return json(data, headers={"Access-Control-Allow-Origin": "*"})

@application.websocket('/feed')
async def feed(request, ws):
    print("Loading Agent...")
    session = UserSession()
    print("Loaded agent, awaiting inncoming message...")
    while True:
        data = await ws.recv()        
        try:
            data = js.loads(data)
            if data["type"] == "help":
                await helpSequence(ws, data)
            elif data["type"] == "start":
                await startSequence(ws)
                session.reconfigure(data["policy"], data["library"])
            elif data["type"] == "restart":
                session.restart()
                await restartSequence(ws)
            elif data["type"] == "set-rl":
                session.changeAgent()
                await setRLSequence(ws, data["value"])
            else:
                await asyncio.sleep(.7)
                await ws.send(js.dumps({"type":"typing"}))
                await asyncio.sleep(1.2)
                response = session.processMessage(data)
                print(response)
                await ws.send(js.dumps(response))
        except Exception as e: 
            print("Error:")
            print(e)
            traceback.print_exc()
            await ws.send(js.dumps({"type":"ERROR", "text":"ERROR"}))



@application.route('/time')
def get_current_time(request):
    return json({'time': time.time()})

def set_envs():
    if not shared_envs:
        print('Loading environments.')
        shared_envs["libssh"] = create_env("DefaultEnv", schemedir=schemedir, apidir=os.path.join(apidir, "libssh"))
        shared_envs["allegro"] = create_env("DefaultEnv", schemedir=schemedir, apidir=os.path.join(apidir, "allegro"))
        rl_agents["libssh"]= create_agent("DefaultLearnedAgent", schemedir=schemedir, modeldir=learneddir_libssh)
        rl_agents["allegro"]=create_agent("DefaultLearnedAgent", schemedir=schemedir, modeldir=learneddir_allegro)
    else:
        print("Error")
    print("Envs and Agents loaded!")
    return

if __name__ == '__main__':
    t = threading.Thread(target=set_envs)
    t.start()
    application.run(host="0.0.0.0", 
                    port=os.environ.get('PORT') or 8002, 
                    debug=True)















